#!/usr/bin/env python3

import subprocess
import json
import argparse
import sys
import time
from typing import Dict, List, Optional, Tuple


class AudioDeviceManager:
    def __init__(self):
        self.audio_devices = {}
        self.bluetooth_devices = {}
        self._check_dependencies()

    def _check_dependencies(self) -> None:
        required_tools = ["blueutil", "SwitchAudioSource"]

        for tool in required_tools:
            try:
                subprocess.run(["which", tool], check=True, capture_output=True)
            except subprocess.CalledProcessError:
                print(f"Error: {tool} is not installed or not in PATH", file=sys.stderr)
                print(
                    f"Please install {tool} before running this script", file=sys.stderr
                )
                sys.exit(1)

    def _run_command(self, cmd: List[str], timeout: int = 10) -> Tuple[bool, str, str]:
        try:
            result = subprocess.run(
                cmd, capture_output=True, text=True, timeout=timeout, check=False
            )
            return result.returncode == 0, result.stdout.strip(), result.stderr.strip()
        except subprocess.TimeoutExpired:
            return False, "", f"Command timed out after {timeout} seconds"
        except Exception as e:
            return False, "", str(e)

    def refresh_devices(self) -> None:
        self._load_audio_devices()
        self._load_bluetooth_devices()

    def _load_audio_devices(self) -> None:
        success, stdout, stderr = self._run_command(
            ["SwitchAudioSource", "-f", "json", "-a"]
        )

        if not success:
            print(f"Error loading audio devices: {stderr}", file=sys.stderr)
            return

        self.audio_devices = {}
        for line in stdout.split("\n"):
            if line.strip():
                try:
                    device = json.loads(line)
                    if "name" not in device or "type" not in device:
                        continue

                    name = device["name"]
                    device_type = device["type"]

                    if device_type not in ["input", "output"]:
                        continue

                    key = f"{name.lower()}:{device_type}"
                    self.audio_devices[key] = device
                except (json.JSONDecodeError, KeyError, TypeError):
                    continue

    def _load_bluetooth_devices(self) -> None:
        success, stdout, stderr = self._run_command(
            ["blueutil", "--paired", "--format", "json"]
        )

        if not success:
            print(f"Error loading Bluetooth devices: {stderr}", file=sys.stderr)
            return

        self.bluetooth_devices = {}
        try:
            if stdout.strip():
                devices = json.loads(stdout)
                for device in devices:
                    name = device["name"]
                    self.bluetooth_devices[name.lower()] = device
        except json.JSONDecodeError as e:
            print(f"Error parsing Bluetooth devices: {e}", file=sys.stderr)

    def list_devices(self) -> None:
        print("=== Audio Devices ===")
        if not self.audio_devices:
            print("No audio devices found")
        else:
            current_output = self.get_current_output_device()
            current_input = self.get_current_input_device()

            print("Output Devices:")
            for _, device in self.audio_devices.items():
                if device["type"] == "output":
                    marker = " (current)" if device["name"] == current_output else ""
                    print(f"  • {device['name']}{marker}")

            print("\nInput Devices:")
            for _, device in self.audio_devices.items():
                if device["type"] == "input":
                    marker = " (current)" if device["name"] == current_input else ""
                    print(f"  • {device['name']}{marker}")

        print("\n=== Bluetooth Devices ===")
        if not self.bluetooth_devices:
            print("No paired Bluetooth devices found")
        else:
            for _, device in self.bluetooth_devices.items():
                status = "connected" if device["connected"] else "disconnected"
                print(f"  • {device['name']} ({status})")

    def get_current_output_device(self) -> Optional[str]:
        success, stdout, _ = self._run_command(["SwitchAudioSource", "-c"])
        return stdout if success else None

    def get_current_input_device(self) -> Optional[str]:
        success, stdout, _ = self._run_command(
            ["SwitchAudioSource", "-c", "-t", "input"]
        )
        return stdout if success else None

    def find_device_by_name(self, device_name: str) -> Tuple[Optional[Dict], str]:
        device_name_lower = device_name.lower()

        for key, device in self.audio_devices.items():
            device_name_from_key = key.split(":")[0]
            if device_name_lower == device_name_from_key:
                return device, "audio"

        if device_name_lower in self.bluetooth_devices:
            return self.bluetooth_devices[device_name_lower], "bluetooth"

        audio_matches = [
            (key, device)
            for key, device in self.audio_devices.items()
            if device_name_lower in key.split(":")[0]
            or key.split(":")[0] in device_name_lower
        ]

        bt_matches = [
            (name, device)
            for name, device in self.bluetooth_devices.items()
            if device_name_lower in name or name in device_name_lower
        ]

        if len(audio_matches) == 1:
            return audio_matches[0][1], "audio"
        elif len(bt_matches) == 1:
            return bt_matches[0][1], "bluetooth"
        elif len(audio_matches) + len(bt_matches) > 1:
            print(f"Multiple devices match '{device_name}':", file=sys.stderr)
            for _, device in audio_matches:
                print(f"  • {device['name']} (audio {device['type']})", file=sys.stderr)
            for _, device in bt_matches:
                print(f"  • {device['name']} (bluetooth)", file=sys.stderr)
            return None, "multiple"

        return None, "not_found"

    def find_audio_device_for_bluetooth(
        self, bt_device_name: str, device_type: str
    ) -> Optional[Dict]:
        if not bt_device_name or not bt_device_name.strip():
            return None

        bt_name_lower = bt_device_name.lower().strip()
        bt_words = [word for word in bt_name_lower.split() if word]

        if not bt_words:
            return None

        for _, audio_device in self.audio_devices.items():
            if audio_device["type"] == device_type:
                audio_name_lower = audio_device["name"].lower()

                if all(word in audio_name_lower for word in bt_words):
                    return audio_device

                if bt_name_lower in audio_name_lower:
                    return audio_device

        return None

    def connect_bluetooth_device(self, device: Dict) -> bool:
        if device["connected"]:
            print(f"✓ {device['name']} is already connected")
            return True

        print(f"Connecting to {device['name']}...")
        success, _, stderr = self._run_command(
            ["blueutil", "--connect", device["address"]], timeout=30
        )

        if not success:
            print(f"✗ Failed to connect to {device['name']}: {stderr}", file=sys.stderr)
            return False

        print("Waiting for device to be ready...")
        for _ in range(10):
            time.sleep(1)
            self._load_audio_devices()
            device_name_lower = device["name"].lower()
            device_found = any(
                device_name_lower in key.split(":")[0]
                for key in self.audio_devices.keys()
            )
            if device_found:
                print(f"✓ {device['name']} connected successfully")
                return True

        print(
            f"⚠ {device['name']} connected but not available as audio device yet",
            file=sys.stderr,
        )
        return True

    def switch_audio_device(
        self, device_name: str, device_type: str = "output"
    ) -> bool:
        if device_type not in ["input", "output"]:
            print(
                f"Invalid device type: {device_type}. Must be 'input' or 'output'",
                file=sys.stderr,
            )
            return False

        audio_device = None
        for _, device in self.audio_devices.items():
            if device["name"] == device_name and device["type"] == device_type:
                audio_device = device
                break

        if not audio_device:
            print(
                f"Audio device '{device_name}' not found for {device_type}",
                file=sys.stderr,
            )
            return False

        print(f"Switching {device_type} to {audio_device['name']}...")

        cmd = ["SwitchAudioSource", "-s", audio_device["name"]]
        if device_type == "input":
            cmd.extend(["-t", "input"])

        success, _, stderr = self._run_command(cmd)

        if success:
            print(f"✓ Switched {device_type} to {audio_device['name']}")
            return True
        else:
            print(f"✗ Failed to switch {device_type}: {stderr}", file=sys.stderr)
            return False

    def switch_to_device(self, device_name: str, device_type: str = "output") -> bool:
        self.refresh_devices()

        device, found_type = self.find_device_by_name(device_name)

        if not device:
            if found_type == "multiple":
                return False
            elif found_type == "not_found":
                print(f"Device '{device_name}' not found", file=sys.stderr)
                print("Use --list to see available devices", file=sys.stderr)
                return False

        if not isinstance(device, dict) or "name" not in device:
            print(f"Invalid device data for '{device_name}'", file=sys.stderr)
            return False

        if found_type == "bluetooth":
            if not self.connect_bluetooth_device(device):
                return False

            self._load_audio_devices()

        if found_type == "bluetooth":
            audio_device = self.find_audio_device_for_bluetooth(
                device["name"], device_type
            )

            if not audio_device:
                print(
                    f"Connected to {device['name']} but it's not available as an audio {device_type} device",
                    file=sys.stderr,
                )
                return False

            actual_device_name = audio_device["name"]
        else:
            actual_device_name = device["name"]

        return self.switch_audio_device(actual_device_name, device_type)


def main():
    parser = argparse.ArgumentParser(
        description="Switch audio input/output devices with automatic Bluetooth connection",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --list                          # List all devices
  %(prog)s "AirPods Pro"                   # Switch output to AirPods Pro
  %(prog)s "AirPods Pro" --input           # Switch input to AirPods Pro
  %(prog)s "MacBook Pro Speakers"         # Switch to built-in speakers
  %(prog)s airpods                        # Partial name matching works too
        """,
    )

    parser.add_argument(
        "device_name",
        nargs="?",
        help="Name of the device to switch to (supports partial matching)",
    )

    parser.add_argument(
        "--input",
        action="store_true",
        help="Switch input device instead of output device",
    )

    parser.add_argument(
        "--list",
        "-l",
        action="store_true",
        help="List all available audio and Bluetooth devices",
    )

    parser.add_argument(
        "--current", "-c", action="store_true", help="Show current audio devices"
    )

    args = parser.parse_args()

    try:
        manager = AudioDeviceManager()
        manager.refresh_devices()
    except KeyboardInterrupt:
        print("\nOperation cancelled by user", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Initialization failed: {e}", file=sys.stderr)
        sys.exit(1)

    if args.list:
        manager.list_devices()
        return

    if args.current:
        current_output = manager.get_current_output_device()
        current_input = manager.get_current_input_device()
        print(f"Current output: {current_output or 'Unknown'}")
        print(f"Current input: {current_input or 'Unknown'}")
        return

    if not args.device_name:
        parser.print_help()
        return

    device_type = "input" if args.input else "output"

    try:
        success = manager.switch_to_device(args.device_name, device_type)
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
